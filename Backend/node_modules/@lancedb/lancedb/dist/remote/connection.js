"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteConnection = void 0;
const arrow_1 = require("../arrow");
const connection_1 = require("../connection");
const table_1 = require("../table");
const util_1 = require("../util");
const client_1 = require("./client");
const table_2 = require("./table");
class RemoteConnection extends connection_1.Connection {
    #dbName;
    #apiKey;
    #region;
    #client;
    #tableCache = new util_1.TTLCache(300000);
    constructor(url, { apiKey, region, hostOverride, timeout }) {
        super();
        apiKey = apiKey ?? process.env.LANCEDB_API_KEY;
        region = region ?? process.env.LANCEDB_REGION;
        if (!apiKey) {
            throw new Error("apiKey is required when connecting to LanceDB Cloud");
        }
        if (!region) {
            throw new Error("region is required when connecting to LanceDB Cloud");
        }
        const parsed = new URL(url);
        if (parsed.protocol !== "db:") {
            throw new Error(`invalid protocol: ${parsed.protocol}, only accepts db://`);
        }
        this.#dbName = parsed.hostname;
        this.#apiKey = apiKey;
        this.#region = region;
        this.#client = new client_1.RestfulLanceDBClient(this.#dbName, this.#apiKey, this.#region, hostOverride, timeout);
    }
    isOpen() {
        return this.#client.isOpen();
    }
    close() {
        return this.#client.close();
    }
    display() {
        return `RemoteConnection(${this.#dbName})`;
    }
    async tableNames(options) {
        const response = await this.#client.get("/v1/table/", {
            limit: options?.limit ?? 10,
            // biome-ignore lint/style/useNamingConvention: <explanation>
            page_token: options?.startAfter ?? "",
        });
        const body = await response.body();
        for (const table of body.tables) {
            this.#tableCache.set(table, true);
        }
        return body.tables;
    }
    async openTable(name, _options) {
        if (this.#tableCache.get(name) === undefined) {
            await this.#client.post(`/v1/table/${encodeURIComponent(name)}/describe/`);
            this.#tableCache.set(name, true);
        }
        return new table_2.RemoteTable(this.#client, name, this.#dbName);
    }
    async createTable(nameOrOptions, data, options) {
        if (typeof nameOrOptions !== "string" && "name" in nameOrOptions) {
            const { name, data, ...options } = nameOrOptions;
            return this.createTable(name, data, options);
        }
        if (data === undefined) {
            throw new Error("data is required");
        }
        if (options?.mode) {
            console.warn("option 'mode' is not supported in LanceDB Cloud", "LanceDB Cloud only supports the default 'create' mode.", "If the table already exists, an error will be thrown.");
        }
        if (options?.embeddingFunction) {
            console.warn("embedding_functions is not yet supported on LanceDB Cloud.", "Please vote https://github.com/lancedb/lancedb/issues/626 ", "for this feature.");
        }
        const { buf } = await table_1.Table.parseTableData(data, options, true /** streaming */);
        await this.#client.post(`/v1/table/${encodeURIComponent(nameOrOptions)}/create/`, buf, {
            config: {
                responseType: "arraybuffer",
            },
            headers: { "Content-Type": "application/vnd.apache.arrow.stream" },
        });
        this.#tableCache.set(nameOrOptions, true);
        return new table_2.RemoteTable(this.#client, nameOrOptions, this.#dbName);
    }
    async createEmptyTable(name, schema, options) {
        if (options?.mode) {
            console.warn(`mode is not supported on LanceDB Cloud`);
        }
        if (options?.embeddingFunction) {
            console.warn("embeddingFunction is not yet supported on LanceDB Cloud.", "Please vote https://github.com/lancedb/lancedb/issues/626 ", "for this feature.");
        }
        const emptyTable = (0, arrow_1.makeEmptyTable)(schema);
        const buf = await (0, arrow_1.fromTableToStreamBuffer)(emptyTable);
        await this.#client.post(`/v1/table/${encodeURIComponent(name)}/create/`, buf, {
            config: {
                responseType: "arraybuffer",
            },
            headers: { "Content-Type": "application/vnd.apache.arrow.stream" },
        });
        this.#tableCache.set(name, true);
        return new table_2.RemoteTable(this.#client, name, this.#dbName);
    }
    async dropTable(name) {
        await this.#client.post(`/v1/table/${encodeURIComponent(name)}/drop/`);
        this.#tableCache.delete(name);
    }
}
exports.RemoteConnection = RemoteConnection;
