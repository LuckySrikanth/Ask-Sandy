"use strict";
// Copyright 2023 LanceDB Developers.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteTable = void 0;
const table_1 = require("../table");
const util_1 = require("../util");
class RemoteTable extends table_1.Table {
    #client;
    #name;
    // Used in the display() method
    #dbName;
    get #tablePrefix() {
        return `/v1/table/${encodeURIComponent(this.#name)}/`;
    }
    get name() {
        return this.#name;
    }
    constructor(client, tableName, dbName) {
        super();
        this.#client = client;
        this.#name = tableName;
        this.#dbName = dbName;
    }
    isOpen() {
        return !this.#client.isOpen();
    }
    close() {
        this.#client.close();
    }
    display() {
        return `RemoteTable(${this.#dbName}; ${this.#name})`;
    }
    async schema() {
        const resp = await this.#client.post(`${this.#tablePrefix}/describe/`);
        // TODO: parse this into a valid arrow schema
        return resp.schema;
    }
    async add(data, options) {
        const { buf, mode } = await table_1.Table.parseTableData(data, options, true);
        await this.#client.post(`${this.#tablePrefix}/insert/`, buf, {
            params: {
                mode,
            },
            headers: {
                "Content-Type": "application/vnd.apache.arrow.stream",
            },
        });
    }
    async update(optsOrUpdates, options) {
        const isValues = "values" in optsOrUpdates && typeof optsOrUpdates.values !== "string";
        const isValuesSql = "valuesSql" in optsOrUpdates &&
            typeof optsOrUpdates.valuesSql !== "string";
        const isMap = (obj) => {
            return obj instanceof Map;
        };
        let predicate;
        let columns;
        switch (true) {
            case isMap(optsOrUpdates):
                columns = Array.from(optsOrUpdates.entries());
                predicate = options?.where;
                break;
            case isValues && isMap(optsOrUpdates.values):
                columns = Array.from(optsOrUpdates.values.entries()).map(([k, v]) => [
                    k,
                    (0, util_1.toSQL)(v),
                ]);
                predicate = optsOrUpdates.where;
                break;
            case isValues && !isMap(optsOrUpdates.values):
                columns = Object.entries(optsOrUpdates.values).map(([k, v]) => [
                    k,
                    (0, util_1.toSQL)(v),
                ]);
                predicate = optsOrUpdates.where;
                break;
            case isValuesSql && isMap(optsOrUpdates.valuesSql):
                columns = Array.from(optsOrUpdates.valuesSql.entries());
                predicate = optsOrUpdates.where;
                break;
            case isValuesSql && !isMap(optsOrUpdates.valuesSql):
                columns = Object.entries(optsOrUpdates.valuesSql).map(([k, v]) => [
                    k,
                    v,
                ]);
                predicate = optsOrUpdates.where;
                break;
            default:
                columns = Object.entries(optsOrUpdates);
                predicate = options?.where;
        }
        await this.#client.post(`${this.#tablePrefix}/update/`, {
            predicate: predicate ?? null,
            updates: columns,
        });
    }
    async countRows(filter) {
        const payload = { predicate: filter };
        return await this.#client.post(`${this.#tablePrefix}/count_rows/`, payload);
    }
    async delete(predicate) {
        const payload = { predicate };
        await this.#client.post(`${this.#tablePrefix}/delete/`, payload);
    }
    async createIndex(column, options) {
        if (options !== undefined) {
            console.warn("options are not yet supported on the LanceDB cloud");
        }
        const indexType = "vector";
        const metric = "L2";
        const data = {
            column,
            // biome-ignore lint/style/useNamingConvention: external API
            index_type: indexType,
            // biome-ignore lint/style/useNamingConvention: external API
            metric_type: metric,
        };
        await this.#client.post(`${this.#tablePrefix}/create_index`, data);
    }
    query() {
        throw new Error("query() is not yet supported on the LanceDB cloud");
    }
    search(_query) {
        throw new Error("search() is not yet supported on the LanceDB cloud");
    }
    vectorSearch(_vector) {
        throw new Error("vectorSearch() is not yet supported on the LanceDB cloud");
    }
    addColumns(_newColumnTransforms) {
        throw new Error("addColumns() is not yet supported on the LanceDB cloud");
    }
    alterColumns(_columnAlterations) {
        throw new Error("alterColumns() is not yet supported on the LanceDB cloud");
    }
    dropColumns(_columnNames) {
        throw new Error("dropColumns() is not yet supported on the LanceDB cloud");
    }
    async version() {
        const resp = await this.#client.post(`${this.#tablePrefix}/describe/`);
        return resp.version;
    }
    checkout(_version) {
        throw new Error("checkout() is not yet supported on the LanceDB cloud");
    }
    checkoutLatest() {
        throw new Error("checkoutLatest() is not yet supported on the LanceDB cloud");
    }
    restore() {
        throw new Error("restore() is not yet supported on the LanceDB cloud");
    }
    optimize(_options) {
        throw new Error("optimize() is not yet supported on the LanceDB cloud");
    }
    async listIndices() {
        return await this.#client.post(`${this.#tablePrefix}/index/list/`);
    }
    toArrow() {
        throw new Error("toArrow() is not yet supported on the LanceDB cloud");
    }
    mergeInsert(_on) {
        throw new Error("mergeInsert() is not yet supported on the LanceDB cloud");
    }
    async indexStats(_name) {
        throw new Error("indexStats() is not yet supported on the LanceDB cloud");
    }
}
exports.RemoteTable = RemoteTable;
